---
layout: post  
title:  rust编程 
categories: linux  
tags: rust 

author: CherieLi

---

* content  

{:toc}  

Rust 中最大的思维转换就是变量的所有权和生命周期，这是几乎所有编程语言都未曾涉及的领域。 

C 开发者，难点是类型系统和泛型编程； 
C++ 开发者，难点主要在类型系统；  
Python/Ruby/JavaScript 开发者，难点在并发处理、类型系统及泛型编程；  
Java 开发者，难点在异步处理和并发安全的理解上；  
Swift 开发者，几乎没有额外的难点，深入理解 Rust 异步处理即可。  


在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。  
那为什么在实际工作中，我们又要避免把大量的数据分配在栈上呢？  
这主要是考虑到调用栈的大小，避免栈溢出（stack overflow）。  
一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧，来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息。 

当我们需要动态大小的内存时，只能使用堆，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上。  


