---
layout: post
title:  锁优化
categories: mutex
tags: mutex
author: CherieLi
---

* content
{:toc}
### 互斥锁与自旋锁

**互斥锁** 是阻塞锁，当某线程无法获取互斥锁时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥锁后，操作系统会激活那个被挂起的线程，让其投入运行。

**自旋锁** 是一种非阻塞锁，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。

std::mutex临界区较小，可考虑使用更轻量级的锁，例如spin lock；  

std::mutex用于保护std::unordered_map，可考虑使用lock free map替代原本的std::unordered_map。


两种锁适用于不同场景：

1.如果是多核处理器，如果预计线程等待锁的时间很短，使用自旋锁是划算的。

2.如果是多核处理器，如果预计线程等待锁的时间较长，建议使用互斥锁。

3.如果是单核处理器，一般建议不要使用自旋锁。因为，在同一时间只有一个线程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等待运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。

4.如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥锁的开销较大。
