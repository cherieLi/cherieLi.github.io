文件名 CMakeLists.txt
mkdir build
cd build
cmake ..
make
make test //进行单元测试
make clean //对构建结果进行清理
make install // 安装到/usr/bin 等文件下


产生的缓存都在build目录下了
#1.最低版本号要求
#cmake version
CMAKE_MINIMUM_REQUIRED(VERSION 2.8)

#2.指定项目的名称，一般和项目的文件夹名称对应
#project name 
PROJECT(hello)
PROJECT(mathfunction)
#3.头文件目录,引入头文件搜索路径
#head file path 
指令语法：
INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)

AFTER 或者 BEFORE 指定了要添加的路径是添加到原有包含列表之前或之后
若指定 SYSTEM 参数，则把被包含的路径当做系统包含路径来处理
If the SYSTEM option is given, the compiler will be told the directories are meant as system include directories on some platforms. Signalling this setting might achieve effects such as the compiler skipping warnings, or these fixed-install system files not being considered in dependency calculations - see compiler docs.


案例：
INCLUDE_DIRECTORIES(
 include
 )

#4.源文件目录
指令的语法是：
aux_source_directory(<dir> <variable>)

案例：
#source directory
AUX_SOURCE_DIRECTORY(. DIR_SRCS)
aux_source_directory(src DIR_LIB_SRCS)
AUX_SOURCE_DIRECTORY(. DIR_TEST1_SRCS)

#5.设置环境变量，编译用到的源文件全部都要放到这里，否则编译能够通过，但是执行的时候会出现各种问题，比如"symbol lookup error xxxxx , undefined symbol"
#set environment variable
SET指令的语法是：
SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])

举例：
SET(TEST_MATH
 ${DIR_SRCS}
 )
SET(SRC_LIST main.c t1.c t2.c)

#6.添加要编译的可执行文件
#add executable file 
ADD_EXECUTABLE(${PROJECT_NAME} ${TEST_MATH})
add_executable(mathfunction main.cc MathFunctions.cc)
add_executable(hello ${DIR_SRCS})

#7.添加链接库，添加可执行文件所需要的库，指定文件链接库文件。
比如我们用到了libm.so（命名规则：lib+name+.so），就添加该库的名称

#add link library
指令语法：
TARGET_LINK_LIBRARIES(target library1<debug | optimized> library2...)

案例：
TARGET_LINK_LIBRARIES(${PROJECT_NAME} m)
TARGET_LINK_LIBRARIES( hello test1 )
#8.添加子目录,子目录下也需要有CMakeLists.txt文件
#add subdirectory
指令语法：
ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
add_subdirectory(src)
add_subdirectory(math)

用子目录的好处：
1.	让每个模块单独编译
2.	便于建立链接库文件，供其他文件使用
3.	下层操作可与上层操作屏蔽分隔开，便于对子目录下的文件进行增删，便于进行管理
#9.生成链接库
#create library
指令语法：
ADD_LIBRARY(libname [SHARED|STATIC|MODULE][EXCLUDE_FROM_ALL]source1 source2 ... sourceN)
类型有三种: 
SHARED，动态库
STATIC，静态库
MODULE，在使用dyld的系统有效，如果不支持dyld，则被当作SHARED对待。

案例：
add_library(helloworld_lib_shared  SHARED ${c_files})  //动态库
add_library(helloworld_lib_static STATIC ${c_files})   //静态库
add_library (math ${DIR_LIB_SRCS})
add_library (test1 ${DIR_TEST1_SRCS})

#10.添加配置文件, config.h ，这个文件由 CMake 从 config.h.in 生成
#add configure file
configure_file (
  "${PROJECT_SOURCE_DIR}/config.h.in"
  "${PROJECT_BINARY_DIR}/config.h"
  )

#11.是否使用某个库
#use library or not
option (USE_MYMATH
       "Use provided math implementation" ON)
#12.启用测试
#start test
enable_testing()


#13.测试帮助信息是否可以正常提示
#test help message
add_test (test_usage Demo)
set_tests_properties (test_usage
  PROPERTIES PASS_REGULAR_EXPRESSION "Usage: .* base exponent")


#14.测试程序是否成功运行
# Test 
add_test (test_5_2 Demo 5 2)
set_tests_properties (test_5_2
 PROPERTIES PASS_REGULAR_EXPRESSION "is 25")

#15.定义一个宏，用来简化测试工作
#define macro
macro (do_test arg1 arg2 result)
  add_test (test_${arg1}_${arg2} Demo ${arg1} ${arg2})
  set_tests_properties (test_${arg1}_${arg2}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result})
endmacro (do_test)

#16.使用定义的宏进行一系列的数据测试
# test by using macro
do_test (5 2 "is 25")
do_test (10 5 "is 100000")
do_test (2 10 "is 1024")

#17.gdb设置debug版本，release版本
#gdb setting
set(CMAKE_BUILD_TYPE "Debug")
set(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
set(CMAKE_BUILD_TYPE "Release")
set(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O3 -Wall")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -O0")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -Wall -Werror -std=c++11 ")

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -Wall -Werror -pthread -std=c++11 ")


#18.版本维护
#version information
set (Demo_VERSION_MAJOR 1)
set (Demo_VERSION_MINOR 0)

major 表示主版本
minor 表示副版本

#19.获取属性值
#get property
get_property(sub_src GLOBAL PROPERTY COMM_SRC)
#20.设置属性值
#set property
set_property(GLOBAL APPEND PROPERTY MODULE_REG_SRC
   ${CMAKE_CURRENT_SOURCE_DIR}/CommandMessageReg.cc)

#21.输出用户定义的信息
#message
MESSAGE指令的语法是：
MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] "message to display"...)
三种类型:
SEND_ERROR，产生错误，生成过程被跳过。
SATUS，输出前缀为—的信息。
FATAL_ERROR，立即终止所有cmake过程。

案例：
message(STATUS "SCRIPT_TYPE: " ${SCRIPT_TYPE})

#22.添加链接库的搜索路径
指令语法：
LINK_DIRECTORIES(directory1 directory2 ...)

案例：
LINK_DIRECTORIES(
  ${COMMON_LIB_PATH}
  ${SLICE_BASE_DIR}/sal/build/SliceServer
  )
#23.设置库的属性
将动态库和静态库的名字设置为一致
set_target_properties(helloworld_lib_shared PROPERTIES OUTPUT_NAME "helloworld")
set_target_properties(helloworld_lib_static PROPERTIES OUTPUT_NAME "helloworld")

设置动态库版本
set_target_properties(helloworld_lib_shared PROPERTIES VERSION 1.2 SOVERSION 1)

#24.日报学习
（1）	linux下有两种库:动态库和静态库(共享库)
不同点在于代码被载入的时刻不同
静态库的代码在编译过程中已经被载入可执行程序,因此体积比较大。
动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小。

静态库这类库的名字一般是libxxx.a
		  好处：编译后的执行程序不需要外部的函数库支持
不足：如果静态函数库改变了，那么你的程序必须重新编译。

动态库这类库名字一般是libxxx.so
程序运行时动态的申请并调用
好处：动态函数库的改变并不影响你的程序，所以动态函数库的升级/更新比较方便。
不足：程序的运行环境中必须提供相应的库。

当静态库和动态库同名时， gcc命令将优先使用动态库.为了确保使用的是静态库, 编译时可以加上 -static  选项，因此多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static
（2） 中间的内容循环依赖
-Wl,--whole-archive -Wl,--start-group
  dswcore dposax dplog dpdiagnose dpumm_mm dphpuc mxml ibverbs dpumm_cmm osax_util
  dposen iod lwt dptracepoint patmatch scpart_mgr dif CommonTools rdmacm
  ibumad ibmad ACE crc32c xnetlite ftdsclient
  -Wl,--end-group -Wl,--no-whole-archive

优秀博客
https://blog.csdn.net/hebbely/article/details/79169965
Cmake知识----编写CMakeLists.txt文件编译C/C++程序

https://www.hahack.com/codes/cmake/
CMake 入门实战

https://www.ibm.com/developerworks/cn/linux/l-cn-cmake/index.html
在 linux 下使用 CMake 构建应用程序

https://blog.csdn.net/jnu_simba/article/details/9569107
动态库（.so）和静态库（.a）的区别

https://www.cnblogs.com/52php/p/5681745.html
《CMake实践》笔记一：PROJECT/MESSAGE/ADD_EXECUTABLE


#24.编译选项

add_definitions 为源文件的编译添加由-D引入的define flag
1.GNU
if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC -Wall -Werror -std=c++11 ")
endif ()
2.Debug
如果要加如下编译选项：
cmake .. –DCMAKE_BUILD_TYPE=Debug
则在CMakeLists中这么写：

if ("${CMAKE_BUILD_TYPE}" STREQUAL "Debug")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -O0")
else ()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -O3")
endif ()

3.COVERAGE
OPTION(ENABLE_COVERAGE "Use gcov" OFF)
MESSAGE(STATUS ENABLE_COVERAGE=${ENABLE_COVERAGE})

如果要加如下编译选项：
cmake .. –DENABLE_COVERAGE=ON
则在CMakeLists中这么写：
if (ENABLE_COVERAGE)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-arcs -ftest-coverage")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fprofile-arcs -ftest-coverage")
ENDIF ()


Makefile
ENABLE_COVERAGE=OFF
ENABLE_COVERAGE=ON
cmake ../ -B. -DENABLE_COVERAGE=${ENABLE_COVERAGE} && \

#*******CI*********************************************************************
add_custom_target(coverage

4.SANITIZER
如果要加如下编译选项：
cmake .. –DENABLE_SANITIZER=TRUE
则在CMakeLists中这么写：

if (ENABLE_SANITIZER)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O1 -fno-inline -fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer")
endif ()

5.LUA
如果要加如下编译选项：
cmake .. -DSCRIPT_TYPE=LUA
则在CMakeLists中这么写：

if ("${SCRIPT_TYPE}" STREQUAL "LUA")
    INCLUDE_DIRECTORIES(${LUA_INC_PATH})
endif ()
6.ODD_MEMDUMP
if (ENABLE_ODD_MEMDUMP)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DENABLE_ODD_MEMDUMP")
endif ()

7.参数控制宏
OPTION(USE_MACRO
"Build the project using macro"
OFF)
 
IF(USE_MACRO)
 
 add_definitions("-DUSE_MACRO")
 
endif(USE_MACRO)

开启:cmake –DUSE_MACRO=on
关闭:cmake –DUSE_MACRO=off

第三方库
生成第三方库：
add_library(helloworld_lib_shared  SHARED ${c_files})  //动态库
add_library(helloworld_lib_static STATIC ${c_files})   //静态库

链接第三方库：
LINK_DIRECTORIES()
target_link_libraries(target, source)
单元测试
# Test cases
enable_testing()
include(CTest)

foreach (src ${TEST_SRC})
    get_filename_component(test_name ${src} NAME_WE)
    add_executable(${test_name} ${src})
    target_link_libraries(${test_name} ...)
    add_test(NAME ${test_name} COMMAND "${CMAKE_CURRENT_BINARY_DIR}/${test_name}")
endforeach (src ${TEST_SRC})
子目录
add_subdirectory()

set(***_SRC ***.cc)
set_property(GLOBAL APPEND PROPERTY ###_SRC ${***_SRC} )

get_property(ALL***_SRC GLOBAL PROPERTY ###_SRC)

不允许在源代码目录下编译
if("${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
    message(FATAL_ERROR "In-source builds are not allowed.")
endif("${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")

预设的编译组态
CMAKE_BUILD_TYPE
① None 编译器预设值
② Debug 产生出错咨询
③ Release 进行执行速度最佳化
④ RelWithDebInfo 进行执行速度最佳化，但仍然会启用debug flag
⑤ MinSizeRel 进行程式码最小化
https://zh.wikibooks.org/zh-sg/CMake_%E5%85%A5%E9%96%80/%E5%8A%A0%E5%85%A5%E7%B7%A8%E8%AD%AF%E9%81%B8%E9%A0%85#%E9%A0%90%E8%A8%AD%E7%9A%84%E7%B7%A8%E8%AD%AF%E7%B5%84%E6%85%8B

CMAKE_CXX_COMPILER_ID
①Clang 使用Clang 编译器
② GNU 使用GCC编译器
③ Intel 使用 Intel C++编译器
④ MSVC 使用Visual Studio C++编译器

统计代码覆盖率
# coverage option
OPTION (ENABLE_COVERAGE "Use gcov" OFF)
MESSAGE(STATUS ENABLE_COVERAGE=${ENABLE_COVERAGE})
IF(ENABLE_COVERAGE)
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-arcs -ftest-coverage")
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fprofile-arcs -ftest-coverage")
#    SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fprofile-arcs -ftest-coverage")
ENDIF()
如果-DENABLE_COVERAGE=ON， 会生成.gcno文件
用gcov-dump可以得到文件分析结果

检查内存地址问题
if (ENABLE_SANITIZER)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O1 -fno-inline -fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer")
endif ()

检查内存泄漏问题
if (ENABLE_LEAK_SANITIZER)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O1 -fno-inline -fsanitize=leak -fsanitize=undefined -fno-omit-frame-pointer")
endif ()

LeakSanitzer 是一个内存泄漏检测器，集成在了AddressSanitizer, 支持x86_64 Linux和OS X
用-fsanitizer=leak 替代-fsanitizer=address, 只做内存泄漏检查，不占用编译时间

https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer

add_dependencies 添加依赖
https://cmake.org/cmake/help/latest/command/add_dependencies.html

get_filename_component
DIRECTORY = Directory without file name
NAME      = File name without directory
EXT       = File name longest extension (.b.c from d/a.b.c)
NAME_WE   = File name without directory or longest extension
LAST_EXT  = File name last extension (.c from d/a.b.c)
NAME_WLE  = File name without directory or last extension
PATH      = Legacy alias for DIRECTORY (use for CMake <= 2.8.11)
https://cmake.org/cmake/help/v3.14/command/get_filename_component.html
