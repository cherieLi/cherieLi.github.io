第一章：了解SQL
数据库：保存有组织的数据的容器（通常是一个文件或一组文件）。
表：某种特定类型数据的结构化清单。
模式：关于数据库和表的布局及特性的信息。
列：表中的一个字段。所有表都是由一个或多个列组成的。
数据类型：所允许的数据的类型。每个表列都有相应的数据类型，它限制（或允许）该列中存储的数据。数据类型限定了可存储在列中的数据种类（例如，防止在数值字段中录入字符值）。数据类型还帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。因此，在创建表时必须特别关注所用的数据类型。
行：表中的一个记录。
主键：一列（或一组列），其值能够唯一标识表中每一行。

任意两行都不具有相同的主键值；
每一行都必须具有一个主键值（主键列不允许 NULL 值）；
主键列中的值不允许修改或更新；
主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）
第二章：检索数据
通配符：一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。
DISTINCT：不能部分使用 DISTINCTDISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。例如，你指定 SELECT DISTINCT vend_id, prod_price，除非指定的两列完全相同，否则所有的行都会被检索出来。
在限制搜索结果时，YashanDB支持，LIMIT 行数 OFFSET 偏移行，使用ROWNUM（行计数器），或者使用FETCH FIRST 行数 ROWS ONLY（即将支持）


第三章：排序检索数据
YashanDB支持多列排序、按列位置排序。
请注意，DESC 是 DESCENDING 的缩写，这两个关键字都可以使用。与 DESC相对的是 ASC（或 ASCENDING），在升序排序时可以指定它。但实际上，ASC 没有多大用处，因为升序是默认的（如果既不指定 ASC 也不指定DESC，则假定为 ASC）。
在对文本性数据进行排序时，A 与 a 相同吗？a 位于 B 之前，还是 Z之后？这些问题不是理论问题，其答案取决于数据库的设置方式。
在字典（dictionary）排序顺序中，A 被视为与 a 相同，这是大多数数据库管理系统的默认行为。但是，许多 DBMS 允许数据库管理员在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。


第四章：过滤数据
WHERE 子句里用单等号。
优先从SQL中过滤，因为省带宽。
WHERE ... ORDER BY ...
WHERE 子句操作符
=	等于
<>	不等于
!<	不小于
!>	不大于
BETWEEN	处于A与B之间
IS NULL	为 NULL 值

NULL 和非匹配：通过过滤选择不包含指定值的所有行时，你可能希望返回含 NULL 值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果。过滤数据时，一定要验证被过滤列中含 NULL 的行确实出现在返回数据中。
第五章：高级数据过滤
求值顺序：AND操作符优先级高于OR操作符，在组合使用时建议使用圆括号包裹。不要过分依赖默认求值顺序，即使它确实如你希望的那样。使用圆括号没有什么坏处，它能消除歧义。
OR和IN选择时，选择IN操作符：

在有很多合法选项时，IN 操作符的语法更清楚，更直观。
在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。
IN 操作符一般比一组 OR 操作符执行得更快（在上面这个合法选项很少的例子中，你看不出性能差异）。
IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立WHERE 子句。
在复杂语句中建议使用NOT关键词，在与IN操作符联合使用时，NOT 可以非常简单地找出与条件列表不匹配的行。

第六章：用通配符进行过滤
通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索。
百分号（%）通配符：%表示任何字符出现任意次数。
下划线（_）通配符：下划线的用途与%一样，但它只匹配单个字符，而不是多个字符。
方括号（[ ]）通配符：方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。如果是否定集则是[^]
区分大小写：根据 DBMS 的不同及其配置，搜索可以是区分大小写的。如果区分大小写，则'fish%'与 Fish bean bag toy 就不匹配。 请注意后面所跟的空格：子句 WHERE prod_name LIKE 'F%y'只匹配以 F 开头、以 y 结尾的 prod_name。如果值后面跟空格，则不是以 y 结尾，所以 Fish bean bag toy 就不会检索出来。简单的解决办法是给搜索模式再增加一个%号：'F%y%'还匹配 y 之后的字符（或空格）。更好的解决办法是用函数去掉空格。
通配符%看起来像是可以匹配任何东西，但有个例外，这就是 NULL。子句 WHERE prod_name LIKE '%'不会匹配产品名称为 NULL 的行。
通配符使用技巧：

不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。
在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。
细注意通配符的位置。如果放错地方，可能不会返回想要的数据。
第七章：创建计算字段
计算字段：存储在表中的数据都不是应用程序所需要的。我们需要直接从数据库中检索出转换、计算或格式化过的数据，而不是检索出数据，然后再在客户端应用程序中重新格式化。从客户端（如应用程序）来看，计算字段的数据与其他列的数据的返回方式相同。
拼接字段可以使用+,||,CONCATE函数。其中YashanDB支持||和CONCAT函数，在YashanDB中+对应数学加法，会将左右两边尝试转化为number类型，失败时报错。
可以使用RTRIM,LTRIM,TRIM去除文本右侧、左侧、两端多余空格。
使用AS关键词赋予字段别名。

第八章：使用函数处理数据
与SQL语句不同，SQL函数是不可移植的。
在YashanDB中获取当前时间的写法如下：

SELECT NOW() FROM DUAL;
SELECT CURRENT_DATE FROM DUAL;
SELECT SYSDATE FROM DUAL; 同时YashanDB未能实现SOUNDEX（）函数。 在完成日期检索的实现上，YashanDB与Oracle一致：SELECT order_num FROM Orders WHERE to_number(to_char(order_date, 'YYYY')) = 2012;。
第九章：汇总数据
SQL聚集函数

AVG()	返回某列平均值，忽略NULL值行
COUNT()	返回某列的行数，COUNT(*)不忽略NULL值行，COUNT(列名)忽略NULL值行
MAX()	返回某列的最大值，在用于文本数据时，MAX()返回按该列排序后的最后一行。忽略NULL值行
MIN()	返回某列的最小值，在用于文本数据时，MIN()返回该列排序后最前面的行。忽略NULL值行
SUM()	返回某列之和，忽略NULL值行
利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。
对所有行执行计算，指定 ALL 参数或不指定参数（因为 ALL 是默认行为）。
只包含不同的值，指定 DISTINCT 参数。ALL 参数不需要指定，因为它是默认行为。如果不指定 DISTINCT，则假定为 ALL。DISTINCT不能用于COUNT(*)，可以用于MAX()和MIN()但没价值。
第十章：分组数据
使用GROUP BY分组规定：

GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。
如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以 不能从个别的列取回数据）。
GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY子句中指定相同的表达式。不能使用别名。
大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。
除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出。
如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。
GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。
HAVING和WHERE区别：WHERE过滤行，而 HAVING 过滤分组。这里有另一种理解方法，WHERE 在数据分组前进行过滤，HAVING 在数据分组后进行过滤。这是一个重要的区别，WHERE 排除的行不包括在分组中。这可能会改变计算值，从而影响 HAVING 子句中基于这些值过滤掉的分组。
ORDER BY与GROUP BY
对产生的输出排序	对行分组，但输出可能不是分组的顺序
任意列都可以使用（甚至非选择的列也可以使用）	只可能使用选择列或表达式列，而且必须使用每个选择列表达式
不一定需要	如果与聚集函数一起使用列（或表达式），则必须使用
一般在使用 GROUP BY 子句时，应该也给出 ORDER BY 子句。这是保证数据正确排序的唯一方法。千万不要仅依赖 GROUP BY 排序数据。
SELECT子句及其顺序：

SELECT	要返回的列或表达式	是
FROM	从中检索数据的表	仅在从表选择数据时使用
WHERE	行级过滤	否
GROUP BY	分组说明	仅在按组计算聚集时使用
HAVING	组级过滤	否
ORDER BY	输出排序顺序	否
第十一章：使用子查询
作为子查询的 SELECT 语句只能查询单个列。企图检索多个列将返回错误，同时需要注意子查询的性能问题，子查询在构造这种SELECT语句时极有用，但必须注意限制有歧义的列。

第十二章：联结表
笛卡尔积：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。
联结表最好使用WHERE子句，否则返回笛卡尔积。
内联结也称为等值联结, SELECT vend_name, prod_name, prod_price FROM Vendors INNER JOIN Products ON Vendors.vend_id = Products.vend_id;。其效果与使用WHERE子句相同。
可使用AND关键联结多个表，但需要注意性能问题。

第十三章：创建高级联结
AS是创建别名的关键词，ORACLE不支持AS关键词，YashanDB支持。
使用表别名的理由：
1、缩短 SQL 语句；
2、允许在一条 SELECT 语句中多次使用相同的表（自联结）。
联结有三种类型：自联结（self-join）、自然联结（natural join）和外联结（outer join）。 、 在自联结和子查询中，需要根据DBMS的处理来选择，YashanDB目前不知道哪个更快。

内联结
标准的联结（内联结）返回所有数据，相同的列甚至多次出现。自然联结排除多次出现，使每一列只返回一次。

自然联结
自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符（SELECT *），而对其他表的列使用明确的子集来完成。
迄今为止建立的每个内联结都是自然联结，很可能永远都不会用到不是自然联结的内联结。

外联结
联结包含了那些在相关表中没有关联行的行。这种联结称为外联结。 在使用 OUTER JOIN 语法时，必须使用 RIGHT 或 LEFT 关键字指定包括其所有行的表。即左外联结和右外联结，它们唯一的差别是所关联的表的顺序。 使用联结和联结条件：

注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。
关于确切的联结语法，应该查看具体的文档，看相应的 DBMS 支持何种语法（大多数 DBMS 使用这两课中描述的某种语法）。
保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据。
应该总是提供联结条件，否则会得出笛卡儿积。
在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单。
第十四章：组合查询
组合查询使用场景：

在一个查询中从不同的表返回结构数据；
对一个表执行多个查询，按一个查询返回数据。 UNION操作符来组合薯条SQL查询，利用UNION可给出多条SELECT语句，将它们的结果组合成一个结果集。
UNION的限制：使用 UNION 组合 SELECT 语句的数目，SQL 没有标准限制。但是，最好是参考一下具体的 DBMS 文档，了解它是否对 UNION 能组合的最大语句数目有限制，在YashanDB DOC中未发现相关描述。
UNION：合并且过滤掉重复值。
UNION ALL：合并且保留重复值。
需要注意性能问题，理论上使用多条WHERE子句条件和UNION应该没有实际的差别。
在组合多表情况且有不匹配列名的表，可以将UNION与别名组合，检索一个结果集。
UNION规则：
UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）。
UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。
列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。
在用 UNION 组合查询时，只能使用一条 ORDER BY 子句，它必须位于最后一条 SELECT 语句之后。（对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条 ORDER BY 子句。）
第十五章：插入数据
插入方式：
1、插入完整的行；
2、插入行的一部分；
3、插入某些查询的结果。

在插入的时候可以省略列，前提是该列定义为允许 NULL 值（无值或空值）或者在表定义中给出默认值。这表示如果不给出值，将使用默认值。
INSERT SELECT 与 SELECT INTO,它们之间的一个重要差别是前者导入数据，而后者导出数据。
目前YashanDB不支持表复制语法SELECT * INTO CustCopy FROM Customers;

第十六章：更新和删除数据
UPDATE Customers SET cust_email = 'kim@thetoystore.com' WHERE cust_id = '1000000005'; 不要省略 WHERE 子句，一不小心会导致全表更新。且在使用UPDATE之前要确保有足够的安全权限。DELETE同理。
UPDATE 语句中可以使用子查询，使得能用 SELECT 语句检索出的数据更新列数据。YashanDB不支持在UPDATE语句中使用FROM子句。
如果想从表中删除所有行，不要使用 DELETE。可使用 TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）。
更新和删除的指导原则：

除非确实打算更新和删除每一行，否则绝对不要使用不带 WHERE 子句的 UPDATE 或 DELETE 语句。
保证每个表都有主键（如果忘记这个内容，请参阅第 12 课），尽可能像 WHERE 子句那样使用它（可以指定各主键、多个值或值的范围）。
在 UPDATE 或 DELETE 语句使用 WHERE 子句前，应该先用 SELECT 进行测试，保证它过滤的是正确的记录，以防编写的 WHERE 子句不正确。
使用强制实施引用完整性的数据库（关于这个内容，请参阅第 12 课），这样 DBMS 将不允许删除其数据与其他表相关联的行。
有的 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 语句。如果所采用的 DBMS 支持这个特性，应该使用它。
第十七章：创建和操纵表
每个表列要么是 NULL 列，要么是 NOT NULL 列，这种状态在创建时由表的定义规定。
指定 NULL：在不指定 NOT NULL 时，多数 DBMS 认为指定的是 NULL，但不是所有的 DBMS 都这样。某些 DBMS 要求指定关键字 NULL，如果不指定将出错。
主键和 NULL 值：主键是其值唯一标识表中每一行的列。只有不允许NULL值的列可作为主键，允许 NULL 值的列不能作为唯一标识。
理解 NULL不要把 NULL 值与空字符串相混淆。NULL 值是没有值，不是空字符串。如果指定''（两个单引号，其间没有字符），这在 NOT NULL 列中是允许的。空字符串是一个有效的值，它不是无值。NULL 值用关键字 NULL而不是空字符串指定。
可以使用DEFAULT关键字去指定默认值。
使用ALTER TABLE更新表原则：

理想情况下，不要在表中包含数据时对其进行更新。应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。
所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。
许多 DBMS 不允许删除或更改表中的列。
多数 DBMS 允许重新命名表中的列。
许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。
使用 ALTER TABLE 更改表结构，必须给出下面的信息：
在 ALTER TABLE 之后给出要更改的表名（该表必须存在，否则将出错）；
列出要做哪些更改。
复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：
(1) 用新的列布局创建一个新表；
(2) 使用 INSERT SELECT 语句从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段；
(3) 检验包含所需数据的新表；
(4) 重命名旧表（如果确定，可以删除它）；
(5) 用旧表原来的名字重命名新表；
(6) 根据需要，重新创建触发器、存储过程、索引和外键。
小心使用 ALTER TABLE：使用 ALTER TABLE 要极为小心，应该在进行改动前做完整的备份（表结构和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据
DROP TABLE可以删除表。
第十八章：使用视图
作为视图，不包含任何列或数据，包含的是一个查询（与正确联结表的相同查询）
视图常见应用：

重用 SQL 语句。
简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。
使用表的一部分而不是整个表。
保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。
更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。
性能问题：因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。
视图创建和使用的一些最常见的规则和限制：
与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）
对于可以创建的视图数目没有限制。
创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。
视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的 DBMS 中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。
许多 DBMS 禁止在视图查询中使用 ORDER BY 子句。
有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。
视图不能索引，也不能有关联的触发器或默认值。
有些 DBMS 把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表。详情请参阅具体的 DBMS 文档。
有些 DBMS 允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新。例如有一个视图，只检索带有电子邮件地址的顾客。如果更新某个顾客，删除他的电子邮件地址，将使该顾客不再属于视图。这是默认行为，而且是允许的，但有的 DBMS 可能会防止这种情况发生。
视图用 CREATE VIEW 语句来创建。CREATE VIEW ProductCustomers AS SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num; 视图重命名：删除视图，可以使用 DROP 语句，其语法为 DROP VIEW viewname;。覆盖（或更新）视图，必须先删除它，然后再重新创建。
SELECT 约束全部适用。
WHERE 子句与 WHERE 子句从视图检索数据时如果使用了一条 WHERE 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。
视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理，重新格式化或保护基础数据。
第十九章：使用存储过程
简单来说，存储过程就是为以后使用而保存的一条或多条 SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理。
为什么使用存储过程？

通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面例子所述）。
由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。
简化对变动的管理。
因为存储过程通常以编译过的形式存储，所以 DBMS 处理命令所需的工作量少，提高了性能。
存在一些只能用在单个请求中的 SQL 元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。
使用存储过程有三个主要的好处，即简单、安全、高性能。
缺陷：
不同 DBMS 中的存储过程语法有所不同。
一般来说，编写存储过程比编写基本 SQL 语句复杂，需要更高的技能，更丰富的经验。
EXECUTE接受存储过程名和需要传递给它的任何参数，执行存储过程的SQL。
在YashanDB中执行CALL或者EXEC执行存储过程。
IN传递值给存储过程，OUT从存储过程返回值，INOUT既传递值也返回值。YashanDB不支持。
该部分YashanDB和Oracle差异还是比较多的，语法也不同需要注意。
第二十章：管理事务处理
关于事务处理需要知道的几个术语：

事务（transaction）指一组 SQL 语句；
回退（rollback）指撤销指定 SQL 语句的过程；
提交（commit）指将未存储的 SQL 语句结果写入数据库表；
保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。
可以回退哪些语句？
事务处理用来管理 INSERT、UPDATE 和 DELETE 语句。不能回退 SELECT语句（回退 SELECT 语句也没有必要），也不能回退 CREATE 或 DROP 操作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。
使用简单的 ROLLBACK 和 COMMIT 语句，就可以写入或撤销整个事务。但是，只对简单的事务才能这样做，复杂的事务可能需要部分提交或回退。
保留点越多越好可以在 SQL 代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能灵活地进行回退。
使用SAVEPOINT delete1;和ROLLBACK TO delete1;来创建保留点和回滚保留点。
第二十一章：使用游标
游标：游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。
使用步骤：
1、在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的 SELECT 语句和游标选项。
2、一旦声明，就必须打开游标以供使用。这个过程用前面定义的 SELECT语句把数据实际检索出来。
3、对于填有数据的游标，根据需要取出（检索）各行。
4、在结束游标使用时，必须关闭游标，可能的话，释放游标（有赖于具体的 DBMS）。
声明游标后，可根据需要频繁地打开和关闭游标。在游标打开时，可根据需要频繁地执行取操作。


显式游标：使用CURSOR...IS命令定义的游标，在其定义时静态绑定了一条SQL语句，不可更改与赋值。
动态游标：使用TYPE...IS REF CURSOR定义的游标变量，可以与不同的SQL语句动态绑定（某一时刻只能与一条SQL语句绑定），只需要这些SQL语句的返回类型与游标变量定义的类型兼容即可。
sys_refcursor：系统预定义的动态游标类型，可直接调用，使用方法与动态游标一致。
分布式部署中不可使用游标变量，但支持使用隐式游标相关属性。
YashanDB在同一时间可打开的游标数目限制为300个。
游标属性：
%isopen	布尔型	判断游标是否打开
%found	布尔型	判断游标是否获取到值
%notfound	布尔型	判断游标是否没有获取到值
%rowcount	BIGINT	当前成功执行的数据行数
在YashanDB中可以进行游标间赋值，规则如下：

显式游标无法作为任何赋值表达式的左值或右值。
两个返回值列项相同的动态游标可相互赋值。
无返回值的游标作为左值时可被任意非显式游标赋值。
有返回值的游标作为左值时将会判断右值游标的返回值列项，若右值游标未绑定SQL语句，或者其返回值列项与左值游标一致，则可赋值。
第二十二章：高级SQL特性
SQL涉及的几个高级数据处理特性：约束、索引和触发器。

约束
主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动，使用关键词PRIMARY KEY，也可以使用CONSTRAINT语法ALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY (vend_id);此语法也可以用于 CREATE TABLE 和 ALTER TABLE 语句。
外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分，使用REFERENCES关键字,也可以使用CONSTRAINT语法ALTER TABLE Orders ADD CONSTRAINT FOREIGN KEY (cust_id) REFERENCES Customers (cust_id)，外键有助防止意外删除，有的 DBMS 支持称为级联删除（cascading delete）的特性。 该特性在从一个表中删除行时删除所有相关的数据。 。
唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别：

表可包含多个唯一约束，但每个表只允许一个主键。
唯一约束列可包含 NULL 值。
唯一约束列可修改或更新。
唯一约束列的值可重复使用。
与主键不一样，唯一约束不能用来定义外键。
检查约束，可在创建表时使用CHECK关键字，或者ADD CONSTRAINT CHECK (gender LIKE '[MF]')检查名未gender的列只包含M或F。
索引
索引用来排序数据以加快搜索和排序操作的速度。
索引使用CREATE INDEX语句创建。
开始创建索引前，应该记住以下内容：

索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS 必须动态地更新索引。
索引数据可能要占用大量的存储空间。
并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处。
索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。
可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。
索引最好定时检查并根据需要调整。
触发器
触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。
与存储过程不一样（存储过程只是简单的存储 SQL 语句），触发器与单个的表相关联。
触发器内的代码具有以下数据的访问权：

INSERT 操作中的所有新数据；
UPDATE 操作中的所有新数据和旧数据；
DELETE 操作中删除的数据。 触发器的一些常见用途：
保证数据一致。
基于某个表的变动在其他表上执行活动。
进行额外的验证并根据需要回退数据。
计算计算列的值或更新时间戳。 使用CREATE TRIGGER语句创建触发器。包括触发器的定义和编译，如果触发器编译失败，依然会被创建，但是会在执行时出错。执行失败的触发器会阻止DML语句事件上的所有触发器，直到它被禁用、删除、或被重建且编译成功。
一个触发器包含如下要素：
触发操作：触发执行的内容，为一个过程体。
触发事件：可以由系统判断的触发过程体执行的事件，即对表的INSERT/UPDATE/DELETE等DML操作。 可以定义单个触发事件，也可以定义多个触发事件的组合（OR逻辑组合） 。
触发时机： 触发过程体执行的时间点，包括BEFORE（触发事件发生前执行）和AFTER（触发事件发生后执行）两种。
触发对象：触发事件所基于的对象，即某张表。
触发类型：包括语句级触发（触发事件发生时，执行一次过程体）和行级触发（触发事件发生时，对其影响的每一行数据均执行一次过程体）两种类型。
触发条件：对于行级触发器，可以由WHEN语句指定一个条件表达式，在触发事件发生且条件表达式结果为true时，过程体才会被执行。
分布式部署中不能创建触发器。
数据库安全
安全性使用 SQL 的GRANT 和 REVOKE 语句来管理。

