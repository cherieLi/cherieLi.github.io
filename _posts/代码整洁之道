第一章：整洁代码
想要写出优雅整洁的代码，我们需要严于律己，在态度上重视这件事，始终尽可能保持代码整洁。代码应该果断决绝，就事论事，没有犹豫或不必要的细节，

第二章：有意义的命名
我们在开发程序的过程中，命名是不可避免的。
通过阅读我总结出一些命名原则需要遵守：

命名必须名副其实、避免误导、统一概念
命名应该做到自注释
命名应该符合有意义的语境
命名小心使用List，因为在程序员眼中list具有特殊意义，若表示多数，建议使用对应名词复数。
第三章：函数
函数应该只做一件事，而如何判断函数是否只做了一件事，就是看能否再拆分出一个函数（该函数不仅只是单纯地重新诠释其实现，只做一件事的函数是无法被拆分成多个区段的）。
每个函数应该只有一个抽象层级，符合自顶向下的代码规则，每个函数都会按顺序将你带入下一抽象层级。
在编写函数的时候，严格注意时序性问题，避免在同一个函数中做了检查操作，又执行了检查成功后的行为（类似于分隔指令与查询，函数要么做什么事，要么回答什么事，二者不可得兼）。
写函数可以先优先实现功能，再细致打磨拆分函数（重点）。
编程就是在用独特的语言描述一个故事，是一种艺术。
在YashanDB的代码出现了大量违背这章规则的代码。

第四章：注释
尽可能做到代码自注释，如果非要使用注释则是一种失败，用代码描述代码含义的一种失败，是一种对失败的弥补。更为重要的原因是，没有人能坚持维护注释。
当然有些注释必不可少，比如法律信息，提供信息，解释意图，阐释，警示，TODO，放大等。与之相对的，循规蹈矩地加注释，注释描述不准确，多余的注释等等都是坏的注释（上一份工作我就被循规蹈矩式的注释折磨过）。

第五章：格式
格式非常重要，关联性高的代码原则上应该聚集在一起（概念关联or使用关联）
同时团队大于个人，应该保证整个项目的代码风格是一致的。

第六章：对象和数据结构
该章解答了我大学时期学习java的一个困惑点，既然所以private变量都通过存取函数提供对外操作接口，那么与公有变量而已并无太大区别，那么为何要这么做？
原因：出现这种困惑的原因在于未对数据结构进行合理的设计，仔细思考其使用场景以及使用对象，导致乱加取值与赋值函数，导致最后的结果，好像设置了私有，又好像没啥用。
另一点在于，抽象，虽然在实现与取用上区别不是特别大。但是在概念上，对该行为进行了抽象，客户无法知道具体实现细节。
对象将数据隐藏在抽象后，提供操作函数，数据结构暴露其数据，不提供函数，故面向对象代码难以添加新函数，因为要修改所有类；面向过程代码难以添加新数据结构，因为必须修改所有函数。
迪米特法则只针对对象，数据结构不适用。但是很多框架和标准要求最简单的数据结构都要有存取函数（这就是造成我困惑的根本原因）。
避免出现对象和数据结构混杂的情况。
DTO(Data Transfer Objects，数据传送对象)，多用于与数据库通信、或套接字传递的消息类场景中。

第七章：错误处理
在编写异常处理代码的时候，我们同样需要遵循编码的原则（开闭原则等等），使代码尽量简洁。在针对null值的处理上面，选择不返回，不传递。

第八章：边界
可以通过学习性测试来快速熟悉掌握第三方库，例如yason库便可通过yason的ut测试去学习掌握（感觉目前对yason的掌握还是不够深，结构理解，但是库的api不够熟悉）。
可以通过适配器模式使用第三方尚未开发出的代码。

第九章：单元测试
TDD三定律：

在编写不能通过的单元测试前，不可编写生产代码。
只可编写刚好无法通过的单元测试，不能编译也算不通过。
只可比那些刚好足以通过当前失败测试的生产代码。
注意，测试代码也需要尽量保持整洁，可读性必须在首位。
第十章：类
在我看来，封装的等级只有严格封装（private）和不封装，无论是protect还是public，你都无法控制有多少个其他类会访问到，所以只有只有严格封装（private）和不封装。
类的权责和它的命名紧密相关，避免出现模糊词。牢记，类也与函数一致，应该也是单一权责。
牢记高内聚，低耦合的原则，拆分大函数的时机实际上也是拆分大类的时机。

第十一章：系统
构造与使用应该进行分离以满足单一职责原则。（延迟初始化/赋值技巧）违法了该原则，特别在初始化/赋值对象是个重型对象时候还会影响到测试。
最简单的方式是通过分解main函数实现，接着是工厂模式，还有java spring的核心DI和IoC。
牢记别使用侵入性结构。

第十二章：迭进
1、测试必须全部通过
2、不可重复（重复的行数程度我就不清楚了）
3、清晰表达出意图
4、尽可能减少类和方法的数量

第十三章：并发编程
对象是过程的抽象，线程是调度的抽象。
并发是一种解耦策略，帮助我们吧做什么（目的）和何时（时机）做分解开。主要场景为：结构需求、性能需求。
迷思和误解：
1、并发总能改进性能。
并发有时候能改进性能，只在多个线程或处理器之间能分享大量等待时机的时候管用
2、编写并发程序无需修改设计
并发算法的设计可能与单线程系统的设计极其不同，目的与时机的解耦往往对系统结构造成巨大的影响。
3、采用容器的时候，并发由容器控制。
并发防御原则：
1、单一职权原则，分离并发相关代码与其他代码。
2、限制数据作用域，谨记数据封装，应该限制对可能被共享的数据的访问。
3、使用数据复本。
4、线程应尽可能独立地共享，将数据分解到可被独立线程操作的独立子集。
考虑系统关闭场景多线程问题，父子进程关闭，类似linux的僵尸进程和孤儿进程。
不要把系统错误归为偶发事件（ci门禁的偶发失败到现在我也没懂）
多线程与单线程应该分开处理，无论实现还是问题修复定位。
可以通过硬编码和自动化的方式进行测试（推荐自动化）。

第十四章：逐步改进
写出脏代码是写出整洁代码必不可少的前置步骤，大多数人都只满足写出了满足功能的代码。或者抱有，“我先实现功能，后面再优化的念头”就像我写yason二进制校验接口一样，由于工作等各种原因而导致并未主动进行优化，最好的优化时机就是意识到可以优化的时候。 当然必须构思后再进行优化，而非一拍脑门决定。

第十五章：JUnit内幕
很多时候，我并不想为了几个判断条件去写一个接口，但实际上是需要的，如codIsValidxxx的时间判断接口（虽然data相关头文件中没提供）。
重构是一种不停试错的迭代过程，没有系统永恒不变，需要考虑后面负责维护的人的体验以及系统一些规格发生改变的情况。

第十六章：重构SerialDate
签入的代码要比签出时整洁。现在能够理解为什么yason的ut测试里面，存在大量函数只服务与ut测试用例。

第十七章：味道与启发
是对前文的总结，后续应该还会时常翻看这章。
总的而言还是老生常谈的几个基本原则和一些规范。
仍然需要结合实际工程代码多看看。
通过自己所能想到的所有单元测试不代表着系统“可以工作”，必须理解其工作的原理，知道为什么选择这个解决方案。（最好的办法就是重构函数）。
