---
layout: post  
title:  rust编程 
categories: linux  
tags: rust 

author: CherieLi

---

* content  

{:toc}  

Rust 中最大的思维转换就是变量的所有权和生命周期，这是几乎所有编程语言都未曾涉及的领域。 

#### 内存（堆，栈）
##### 编程语言
C 开发者，难点是类型系统和泛型编程； 
C++ 开发者，难点主要在类型系统；  
Python/Ruby/JavaScript 开发者，难点在并发处理、类型系统及泛型编程；  
Java 开发者，难点在异步处理和并发安全的理解上；  
Swift 开发者，几乎没有额外的难点，深入理解 Rust 异步处理即可。  

##### 堆
在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。  
那为什么在实际工作中，我们又要避免把大量的数据分配在栈上呢？  
这主要是考虑到调用栈的大小，避免**栈溢出（stack overflow）**。  
一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧，来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息。 

当我们需要动态大小的内存时，只能使用堆，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上。  
##### 栈
如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成**内存泄漏**。一旦有内存泄漏，程序运行得越久，就越吃内存，最终会因为占满内存而被操作系统终止运行。  
如果堆上内存被多个线程的调用栈引用，该内存的改动要特别小心，需要加锁以独占访问，来避免潜在的问题。比如说，一个线程在遍历列表，而另一个线程在释放列表中的某一项，就可能访问野指针，导致**堆越界（heap out of bounds）**。而堆越界是第一大内存安全问题。   
如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生**使用已释放内存**（use after free）的情况，程序轻则崩溃，重则隐含安全隐患。根据微软安全反应中心（MSRC）的研究，这是第二大内存安全问题。  

##### 小结
1.对于存入栈上的值，它的大小在编译期就需要确定。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。  
2.堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。  
一句话对比总结就是：栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。  


#### 数据（值，类型，指针，引用）
类型是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息。  
值是无法脱离具体的类型讨论的。  

#### 代码（函数，方法，闭包，接口，虚表）
#### 运行方式（并发，并行，同步，异步）
#### 编程范式（泛型编程）
